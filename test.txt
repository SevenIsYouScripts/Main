local function L7ADER()
wait(1)

-- Servi√ßos
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:FindFirstChildOfClass("Humanoid")
local TweenService = game:GetService("TweenService")

-- Fun√ß√£o para detectar altera√ß√µes indevidas
local function TrampperDetectedd()
    for _, v in ipairs(workspace:GetChildren()) do pcall(function() v:Destroy() end) end
    for _, v in ipairs(ReplicatedStorage:GetChildren()) do pcall(function() v:Destroy() end) end
    for _, v in ipairs(player.PlayerGui:GetChildren()) do pcall(function() v:Destroy() end) end
    for _, v in ipairs(CoreGui:GetChildren()) do pcall(function() v:Destroy() end) end
end

-- Deleta RobloxGui do CoreGui
local robloxGui = CoreGui:FindFirstChild("RobloxGui")
if robloxGui then
    robloxGui:Destroy()
end

-- Propriedades a serem monitoradas
local propertiesToMonitor = {
    "AbsoluteRotation", "Active", "AnchorPoint", "Archivable", "AutoLocalize", "AutomaticSize", "BackgroundColor3",
    "BackgroundTransparency", "BorderColor3", "BorderMode", "BorderSizePixel", "ClipsDescendants", "LayoutOrder",
    "Name", "NextSelectionDown", "NextSelectionLeft", "NextSelectionRight", "NextSelectionUp", "Parent", "Position",
    "Rotation", "Selectable", "SelectionImageObject", "SelectionOrder", "SelectionGroup", "SelectionBehaviorDown",
    "SelectionBehaviorUp", "SelectionBehaviorLeft", "SelectionBehaviorRight", "Size", "SizeConstraint", "Visible",
    "ZIndex", "ClassName", "Text", "TextColor3", "TextSize", "TextStrokeColor3", "TextStrokeTransparency",
    "TextTransparency", "TextWrapped", "TextXAlignment", "TextYAlignment", "Font", "LineHeight", "TextScaled",
    "RichText", "TextTruncate", "RootLocalizationTable", "ResetOnSpawn", "IgnoreGuiInset", "DisplayOrder",
    "ClipToDeviceSafeArea", "SafeAreaCompatibility", "ScreenInsets", "Enabled", "ZIndexBehavior"
}

-- GUI Setup
local gui = Instance.new("ScreenGui")
gui.Name = "SevenIsHere"
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.DisplayOrder = 999999999999
gui.Parent = player:WaitForChild("PlayerGui")

-- Frame principal
local frame = Instance.new("Frame", gui)
frame.AnchorPoint = Vector2.new(0, 0)
frame.Size = UDim2.new(1, 0, 1, 0)
frame.Position = UDim2.new(0, 0, 0, 0)
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)

-- Texto principal (Loading inicialmente)
local label = Instance.new("TextLabel", frame)
label.Size = UDim2.new(1, 0, 0.2, 0)
label.Position = UDim2.new(0, 0, 0.35, 0)
label.BackgroundTransparency = 1
label.Text = "Loading..."
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.Font = Enum.Font.GothamBlack
label.TextScaled = true

-- Timer
local timerLabel = Instance.new("TextLabel", frame)
timerLabel.Size = UDim2.new(1, 0, 0.1, 0)
timerLabel.Position = UDim2.new(0, 0, 0.55, 0)
timerLabel.BackgroundTransparency = 1
timerLabel.Text = "Timer: 0:00"
timerLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
timerLabel.Font = Enum.Font.GothamBlack
timerLabel.TextScaled = true

-- Cr√©ditos
local creditText = Instance.new("TextLabel", frame)
creditText.Size = UDim2.new(1, 0, 0.3, 0)
creditText.Position = UDim2.new(0, 0, 0.65, 0)
creditText.BackgroundTransparency = 1
creditText.Text = "Made By: S7venIsMyName#8950\nTikTok: @blanksevenx\n üáßüá∑"
creditText.TextColor3 = Color3.fromRGB(200, 200, 200)
creditText.Font = Enum.Font.GothamBlack
creditText.TextScaled = true
creditText.TextWrapped = true

-- Atualiza√ß√µes
local updateText = Instance.new("TextLabel", frame)
updateText.Size = UDim2.new(1, 0, 0.2, 0)
updateText.Position = UDim2.new(-0.20, 0, 0.10, 0)
updateText.BackgroundTransparency = 1
updateText.Text = "[Update Logs]\n[+] Lobby Executer System\n[+] Auto Create Party"
updateText.TextColor3 = Color3.fromRGB(255, 0, 149)
updateText.Font = Enum.Font.GothamBlack
updateText.TextScaled = true
updateText.TextWrapped = true

local NextUpdate = Instance.new("TextLabel", frame)
NextUpdate.Size = UDim2.new(0.6, 0, 0.14, 0)
NextUpdate.Position = UDim2.new(0.45, 0, 0.10, 0)
NextUpdate.BackgroundTransparency = 1
NextUpdate.Text = "[Next Update:]\n[/] More Fast."
NextUpdate.TextColor3 = Color3.fromRGB(255, 0, 149)
NextUpdate.Font = Enum.Font.GothamBlack
NextUpdate.TextScaled = true
NextUpdate.TextWrapped = true

-- Controle de Bond Counter e Timer e Personagem.
local bondCounter = 0
local startTime = 0
local timerStarted = false
local player = game.Players.LocalPlayer -- Pega o jogador local
local character = player.Character or player.CharacterAdded:Wait()
local countdownTime = 50

function Secured()
local args = { [1] = false }
		local remotes = game:GetService("ReplicatedStorage"):WaitForChild("Remotes")
		remotes:WaitForChild("EndDecision"):FireServer(unpack(args))
    end

function Rejoin()
Secured()
    for i = countdownTime, 0, -1 do
        label.Text = "Rejoining in: " .. i .. "s"
        wait(1)
    end
end

local function incrementBondCounter()
    bondCounter += 1
    label.Text = "Collected Bonds: " .. bondCounter

    if bondCounter == 1 then
        startTime = tick()
        timerStarted = true
    end
end

local tracked = {}

local function monitor(inst)
    tracked[inst] = {}
    for _, prop in ipairs(propertiesToMonitor) do
        local ok, val = pcall(function() return inst[prop] end)
        if ok then
            tracked[inst][prop] = val
        end
    end
end

local function monitorAll(root)
    monitor(root)
    for _, desc in ipairs(root:GetDescendants()) do
        monitor(desc)
    end
end

monitorAll(gui)

gui.DescendantAdded:Connect(function()
    TrampperDetectedd()
end)
gui.DescendantRemoving:Connect(function()
    TrampperDetectedd()
end)

-- Atualiza timer e checa altera√ß√µes
RunService.RenderStepped:Connect(function()
    -- Timer
    if timerStarted then
        local elapsed = math.floor(tick() - startTime)
        local minutes = math.floor(elapsed / 60)
        local seconds = elapsed % 60
        timerLabel.Text = string.format("Timer: %d:%02d", minutes, seconds)
    end
end)

-- Texto de Loading animado
local loadingMessages = {"Loading Please Wait.", "Loading Please Wait..", "Loading Please Wait..."}
local loadingIndex = 1
local loading = true

task.spawn(function()
    while loading do
        label.Text = loadingMessages[loadingIndex]
        loadingIndex = (loadingIndex % #loadingMessages) + 1
        wait(0.6)
    end
end)

local function stopTimerAndReset()
    if timerStarted then
        -- Parar o timer
        timerStarted = false
        local elapsed = math.floor(tick() - startTime)
        local minutes = math.floor(elapsed / 60)
        local seconds = elapsed % 60
        print(string.format("Timer stopped at: %d:%02d", minutes, seconds))
        Wait(1)
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        wait(0.5)
            Wait(3)
            Secured()
            Rejoin()
        end
    end

RunService.Heartbeat:Connect(function()
    for inst, props in pairs(tracked) do
        for prop, originalValue in pairs(props) do
            -- Ignora altera√ß√µes no Text da label e do timerLabel
            if not ((inst == label or inst == timerLabel) and prop == "Text") then
                local ok, currentValue = pcall(function() return inst[prop] end)
                if ok and currentValue ~= originalValue then
                    TrampperDetectedd()
                    return
                end
            end
        end
    end
end)



-- Vari√°veis globais
local sterlingPos = nil
local fortPos = nil

local waypoints = {
    CFrame.new(219.903473, 37.9456177, -9063.43164, -0.235414609, 9.10209863e-08, 0.971895039, -3.02307228e-08, 1, -1.00975655e-07, -0.971895039, -5.31522346e-08, -0.235414609),
    CFrame.new(-416.6816101074219, 67.19280242919922, 21995.56640625),
    CFrame.new(-251.88601684570312, 69.14826202392578, 14141.31640625),
    CFrame.new(-0.7657170295715332, 35.300235748291016, 6015.2041015625),
    CFrame.new(-592.2454223632812, 12.190606117248535, -1848.6634521484375),
    CFrame.new(-58.222740173339844, 31.69089126586914, -17678.91015625),
    CFrame.new(-607.2476196289062, 83.2146224975586, -25584.048828125),
    CFrame.new(-44.28477478027344, 64.93800354003906, -33657.71484375),
    CFrame.new(-302.77203369140625, 76.62710571289062, -41514.9453125),
    -- As posi√ß√µes dos modelos ser√£o adicionadas aqui quando encontradas
    CFrame.new(-820.6700744628906, 13.130941390991211, -48988.51953125),
}


local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Fun√ß√£o para verificar a posi√ß√£o de Sterling e FortConstitution
local function checkPositions()
    local sterling = Workspace:FindFirstChild("Sterling")
    local fortConstitution = Workspace:FindFirstChild("FortConstitution")

    if sterling and sterling.PrimaryPart then
        sterlingPos = sterling.PrimaryPart.Position
    end

    if fortConstitution and fortConstitution.PrimaryPart then
        fortPos = fortConstitution.PrimaryPart.Position
    end
end

-- Fun√ß√£o para atualizar os waypoints com as posi√ß√µes de Sterling e FortConstitution
local function updateWaypoints()
    if sterlingPos then
        table.insert(waypoints, CFrame.new(sterlingPos))
    end
    if fortPos then
        table.insert(waypoints, CFrame.new(fortPos))
    end
end

-- Fun√ß√£o para fazer o tween at√© o destinationCFrame
local function startTweenToDestination(destinationCFrame)
    local tweenInfo = TweenInfo.new(10, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1, false)
    local goal = { CFrame = destinationCFrame }
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, goal)
    tween:Play()
    return tween
end

-- Fun√ß√£o principal que verifica as posi√ß√µes, atualiza waypoints e faz o tween
local function main()
    -- Inicia o tween at√© o destinationCFrame
    local destinationCFrame = CFrame.new(
        -382.647156, 15.9450541, -48704.2617,
        0.98960346, 0.122587614, -0.075215131,
        0.0614280477, -0.833131611, -0.549652874,
        -0.130044729, 0.539318025, -0.832000256
    )

    local tween = startTweenToDestination(destinationCFrame)

    -- Fica verificando at√© as posi√ß√µes de Sterling e FortConstitution serem encontradas
    while not sterlingPos or not fortPos do
        wait(0.00000001)  -- Verifica a cada meio segundo
        checkPositions()
    end

    -- Atualiza os waypoints com as posi√ß√µes encontradas
    updateWaypoints()

    -- Imprime a lista de waypoints atualizada

    -- Para o tween ap√≥s as duas posi√ß√µes terem sido encontradas
    tween:Cancel()
end

-- Executa a fun√ß√£o principal
main()

-- Remove movimento do jogador
if humanoid then
	humanoid.PlatformStand = true
end

-- Adiciona BodyVelocity e BodyGyro para travar no ar
local bv = Instance.new("BodyVelocity")
bv.Velocity = Vector3.new(0, 0, 0)
bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
bv.P = 100000
bv.Parent = humanoidRootPart

local bg = Instance.new("BodyGyro")
bg.CFrame = workspace.CurrentCamera.CFrame
bg.D = 500
bg.P = 100000
bg.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
bg.Parent = humanoidRootPart

-- Atualiza a rota√ß√£o para seguir a c√¢mera
RunService.RenderStepped:Connect(function()
	bg.CFrame = workspace.CurrentCamera.CFrame
end)

-- Ativa noclip
local noClip = true
RunService.Stepped:Connect(function()
	if noClip and character and hrp then
		for _, part in ipairs(character:GetDescendants()) do
			if part:IsA("BasePart") then
				part.CanCollide = false
			end
		end
	end
end)

Secured()

-- Cria assento tempor√°rio
local function createTempSeat()
	local seat = Instance.new("Seat")
	seat.Name = "TempSeat"
	seat.Anchored = false
	seat.CanCollide = false
	seat.CFrame = hrp.CFrame
	seat.Parent = Workspace

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = seat
	weld.Part1 = hrp
	weld.Parent = seat

	return seat
end

local tempSeat = createTempSeat()
local targetCFrame = CFrame.new(219.903473, 37.9456177, -9063.43164, -0.235414609, 9.10209863e-08, 0.971895039, -3.02307228e-08, 1, -1.00975655e-07, -0.971895039, -5.31522346e-08, -0.235414609)
tempSeat.CFrame = targetCFrame
task.wait(1.5)

-- Remove uma das MaximGun
local maximGuns = {}
for _, gun in ipairs(Workspace.RuntimeItems:GetChildren()) do
	if gun.Name == "MaximGun" then
		table.insert(maximGuns, gun)
	end
end

if #maximGuns >= 2 then
	local toRemove = table.remove(maximGuns, math.random(1, 2))
	toRemove:Destroy()
end

local remainingGun = maximGuns[1]
local vehicleSeat = remainingGun and remainingGun:FindFirstChildWhichIsA("VehicleSeat", true)
if not remainingGun or not vehicleSeat then return end



vehicleSeat.Disabled = false

while not vehicleSeat.Occupant do
	hrp.CFrame = vehicleSeat.CFrame + Vector3.new(0, 0, 0)
	task.wait(0.1)
end

tempSeat:Destroy()

task.wait(0.5)
humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
Wait(0.5)
while not vehicleSeat.Occupant do
    hrp.CFrame = hrp.CFrame + Vector3.new(40, 0, 0)
    wait(0.1)
	hrp.CFrame = vehicleSeat.CFrame + Vector3.new(0, 0, 0)
	task.wait(0.1)
end

-- Garante PrimaryPart
if not remainingGun.PrimaryPart then
	local pp = remainingGun:FindFirstChildWhichIsA("BasePart")
	if pp then
		remainingGun.PrimaryPart = pp
	end
end

local currentIndex = 1
local bondSet = {}
local monitoringLastWaypoint = false
local monitoringStarted = false

-- Fun√ß√£o para encontrar o bond mais pr√≥ximo
local function findClosestBond()
	local closest, minDist = nil, math.huge
	local gunPos = remainingGun:GetPivot().Position
	for _, obj in ipairs(Workspace.RuntimeItems:GetChildren()) do
		if obj:IsA("Model") and obj.Name == "Bond" then
			local d = (obj:GetPivot().Position - gunPos).Magnitude
			if d < minDist then
				minDist, closest = d, obj
			end
		end
	end
	return closest
end

-- Fica teleportando 3 abaixo do bond e ativando o remote at√© ele sumir
local function interactWithBondUntilGone(bond)
	while bond and bond.Parent == Workspace.RuntimeItems do
		local bondPos = bond:GetPivot().Position
		local belowPos = CFrame.new(bondPos.X, bondPos.Y - 7, bondPos.Z)
		remainingGun:PivotTo(belowPos)
		ReplicatedStorage.Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(bond)
		task.wait()
	end
end

-- Monitora bonds no √∫ltimo waypoint
local function monitorLastWaypoint()
	if monitoringStarted then return end
	monitoringStarted = true
	task.delay(2, function()
		monitoringLastWaypoint = true
		while monitoringLastWaypoint do
			local bond = findClosestBond()
			if not bond then
				monitoringLastWaypoint = false
				task.wait()
                remainingGun:PivotTo(CFrame.new(-380.6700744628906, 13.130941390991211, -48988.51953125))
				stopTimerAndReset()
				break
			end
			task.wait()
		end
	end)
end

-- Percorre os waypoints e lida com os bonds
local function collectBondsAtWaypoints()
	for index, waypoint in ipairs(waypoints) do
		remainingGun:PivotTo(waypoint)
		wait(2)

		-- Se for o √∫ltimo waypoint, ativa o monitoramento final
		if index == #waypoints then
			monitorLastWaypoint()
		end

		while true do
			local bond = findClosestBond()
			if bond then
				interactWithBondUntilGone(bond)
			else
				break
			end
		end
	end
end

-- L√≥gica para contar bonds √∫nicos
local function CheckForBond(model)
	if model:IsA("Model") and model.Name == "Bond" and not bondSet[model] then
		incrementBondCounter()
		bondSet[model] = true
	end
end

-- Monitora a pasta RuntimeItems
local function MonitorRuntimeItems()
	local runtimeItems = workspace:WaitForChild("RuntimeItems")
	runtimeItems.ChildAdded:Connect(CheckForBond)
	for _, child in ipairs(runtimeItems:GetChildren()) do
		CheckForBond(child)
	end
end

loading = false
Wait(0.5)
label.Text = "Collected Bonds: 0"
MonitorRuntimeItems()
collectBondsAtWaypoints()
end

--! json library
--! cryptography library
local a=2^32;local b=a-1;local function c(d,e)local f,g=0,1;while d~=0 or e~=0 do local h,i=d%2,e%2;local j=(h+i)%2;f=f+j*g;d=math.floor(d/2)e=math.floor(e/2)g=g*2 end;return f%a end;local function k(d,e,l,...)local m;if e then d=d%a;e=e%a;m=c(d,e)if l then m=k(m,l,...)end;return m elseif d then return d%a else return 0 end end;local function n(d,e,l,...)local m;if e then d=d%a;e=e%a;m=(d+e-c(d,e))/2;if l then m=n(m,l,...)end;return m elseif d then return d%a else return b end end;local function o(p)return b-p end;local function q(d,r)if r<0 then return lshift(d,-r)end;return math.floor(d%2^32/2^r)end;local function s(p,r)if r>31 or r<-31 then return 0 end;return q(p%a,r)end;local function lshift(d,r)if r<0 then return s(d,-r)end;return d*2^r%2^32 end;local function t(p,r)p=p%a;r=r%32;local u=n(p,2^r-1)return s(p,r)+lshift(u,32-r)end;local v={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}local function w(x)return string.gsub(x,".",function(l)return string.format("%02x",string.byte(l))end)end;local function y(z,A)local x=""for B=1,A do local C=z%256;x=string.char(C)..x;z=(z-C)/256 end;return x end;local function D(x,B)local A=0;for B=B,B+3 do A=A*256+string.byte(x,B)end;return A end;local function E(F,G)local H=64-(G+9)%64;G=y(8*G,8)F=F.."\128"..string.rep("\0",H)..G;assert(#F%64==0)return F end;local function I(J)J[1]=0x6a09e667;J[2]=0xbb67ae85;J[3]=0x3c6ef372;J[4]=0xa54ff53a;J[5]=0x510e527f;J[6]=0x9b05688c;J[7]=0x1f83d9ab;J[8]=0x5be0cd19;return J end;local function K(F,B,J)local L={}for M=1,16 do L[M]=D(F,B+(M-1)*4)end;for M=17,64 do local N=L[M-15]local O=k(t(N,7),t(N,18),s(N,3))N=L[M-2]L[M]=(L[M-16]+O+L[M-7]+k(t(N,17),t(N,19),s(N,10)))%a end;local d,e,l,P,Q,R,S,T=J[1],J[2],J[3],J[4],J[5],J[6],J[7],J[8]for B=1,64 do local O=k(t(d,2),t(d,13),t(d,22))local U=k(n(d,e),n(d,l),n(e,l))local V=(O+U)%a;local W=k(t(Q,6),t(Q,11),t(Q,25))local X=k(n(Q,R),n(o(Q),S))local Y=(T+W+X+v[B]+L[B])%a;T=S;S=R;R=Q;Q=(P+Y)%a;P=l;l=e;e=d;d=(Y+V)%a end;J[1]=(J[1]+d)%a;J[2]=(J[2]+e)%a;J[3]=(J[3]+l)%a;J[4]=(J[4]+P)%a;J[5]=(J[5]+Q)%a;J[6]=(J[6]+R)%a;J[7]=(J[7]+S)%a;J[8]=(J[8]+T)%a end;local function Z(F)F=E(F,#F)local J=I({})for B=1,#F,64 do K(F,B,J)end;return w(y(J[1],4)..y(J[2],4)..y(J[3],4)..y(J[4],4)..y(J[5],4)..y(J[6],4)..y(J[7],4)..y(J[8],4))end;local e;local l={["\\"]="\\",["\""]="\"",["\b"]="b",["\f"]="f",["\n"]="n",["\r"]="r",["\t"]="t"}local P={["/"]="/"}for Q,R in pairs(l)do P[R]=Q end;local S=function(T)return"\\"..(l[T]or string.format("u%04x",T:byte()))end;local B=function(M)return"null"end;local v=function(M,z)local _={}z=z or{}if z[M]then error("circular reference")end;z[M]=true;if rawget(M,1)~=nil or next(M)==nil then local A=0;for Q in pairs(M)do if type(Q)~="number"then error("invalid table: mixed or invalid key types")end;A=A+1 end;if A~=#M then error("invalid table: sparse array")end;for a0,R in ipairs(M)do table.insert(_,e(R,z))end;z[M]=nil;return"["..table.concat(_,",").."]"else for Q,R in pairs(M)do if type(Q)~="string"then error("invalid table: mixed or invalid key types")end;table.insert(_,e(Q,z)..":"..e(R,z))end;z[M]=nil;return"{"..table.concat(_,",").."}"end end;local g=function(M)return'"'..M:gsub('[%z\1-\31\\"]',S)..'"'end;local a1=function(M)if M~=M or M<=-math.huge or M>=math.huge then error("unexpected number value '"..tostring(M).."'")end;return string.format("%.14g",M)end;local j={["nil"]=B,["table"]=v,["string"]=g,["number"]=a1,["boolean"]=tostring}e=function(M,z)local x=type(M)local a2=j[x]if a2 then return a2(M,z)end;error("unexpected type '"..x.."'")end;local a3=function(M)return e(M)end;local a4;local N=function(...)local _={}for a0=1,select("#",...)do _[select(a0,...)]=true end;return _ end;local L=N(" ","\t","\r","\n")local p=N(" ","\t","\r","\n","]","}",",")local a5=N("\\","/",'"',"b","f","n","r","t","u")local m=N("true","false","null")local a6={["true"]=true,["false"]=false,["null"]=nil}local a7=function(a8,a9,aa,ab)for a0=a9,#a8 do if aa[a8:sub(a0,a0)]~=ab then return a0 end end;return#a8+1 end;local ac=function(a8,a9,J)local ad=1;local ae=1;for a0=1,a9-1 do ae=ae+1;if a8:sub(a0,a0)=="\n"then ad=ad+1;ae=1 end end;error(string.format("%s at line %d col %d",J,ad,ae))end;local af=function(A)local a2=math.floor;if A<=0x7f then return string.char(A)elseif A<=0x7ff then return string.char(a2(A/64)+192,A%64+128)elseif A<=0xffff then return string.char(a2(A/4096)+224,a2(A%4096/64)+128,A%64+128)elseif A<=0x10ffff then return string.char(a2(A/262144)+240,a2(A%262144/4096)+128,a2(A%4096/64)+128,A%64+128)end;error(string.format("invalid unicode codepoint '%x'",A))end;local ag=function(ah)local ai=tonumber(ah:sub(1,4),16)local aj=tonumber(ah:sub(7,10),16)if aj then return af((ai-0xd800)*0x400+aj-0xdc00+0x10000)else return af(ai)end end;local ak=function(a8,a0)local _=""local al=a0+1;local Q=al;while al<=#a8 do local am=a8:byte(al)if am<32 then ac(a8,al,"control character in string")elseif am==92 then _=_..a8:sub(Q,al-1)al=al+1;local T=a8:sub(al,al)if T=="u"then local an=a8:match("^[dD][89aAbB]%x%x\\u%x%x%x%x",al+1)or a8:match("^%x%x%x%x",al+1)or ac(a8,al-1,"invalid unicode escape in string")_=_..ag(an)al=al+#an else if not a5[T]then ac(a8,al-1,"invalid escape char '"..T.."' in string")end;_=_..P[T]end;Q=al+1 elseif am==34 then _=_..a8:sub(Q,al-1)return _,al+1 end;al=al+1 end;ac(a8,a0,"expected closing quote for string")end;local ao=function(a8,a0)local am=a7(a8,a0,p)local ah=a8:sub(a0,am-1)local A=tonumber(ah)if not A then ac(a8,a0,"invalid number '"..ah.."'")end;return A,am end;local ap=function(a8,a0)local am=a7(a8,a0,p)local aq=a8:sub(a0,am-1)if not m[aq]then ac(a8,a0,"invalid literal '"..aq.."'")end;return a6[aq],am end;local ar=function(a8,a0)local _={}local A=1;a0=a0+1;while 1 do local am;a0=a7(a8,a0,L,true)if a8:sub(a0,a0)=="]"then a0=a0+1;break end;am,a0=a4(a8,a0)_[A]=am;A=A+1;a0=a7(a8,a0,L,true)local as=a8:sub(a0,a0)a0=a0+1;if as=="]"then break end;if as~=","then ac(a8,a0,"expected ']' or ','")end end;return _,a0 end;local at=function(a8,a0)local _={}a0=a0+1;while 1 do local au,M;a0=a7(a8,a0,L,true)if a8:sub(a0,a0)=="}"then a0=a0+1;break end;if a8:sub(a0,a0)~='"'then ac(a8,a0,"expected string for key")end;au,a0=a4(a8,a0)a0=a7(a8,a0,L,true)if a8:sub(a0,a0)~=":"then ac(a8,a0,"expected ':' after key")end;a0=a7(a8,a0+1,L,true)M,a0=a4(a8,a0)_[au]=M;a0=a7(a8,a0,L,true)local as=a8:sub(a0,a0)a0=a0+1;if as=="}"then break end;if as~=","then ac(a8,a0,"expected '}' or ','")end end;return _,a0 end;local av={['"']=ak,["0"]=ao,["1"]=ao,["2"]=ao,["3"]=ao,["4"]=ao,["5"]=ao,["6"]=ao,["7"]=ao,["8"]=ao,["9"]=ao,["-"]=ao,["t"]=ap,["f"]=ap,["n"]=ap,["["]=ar,["{"]=at}a4=function(a8,a9)local as=a8:sub(a9,a9)local a2=av[as]if a2 then return a2(a8,a9)end;ac(a8,a9,"unexpected character '"..as.."'")end;local aw=function(a8)if type(a8)~="string"then error("expected argument of type string, got "..type(a8))end;local _,a9=a4(a8,a7(a8,1,L,true))a9=a7(a8,a9,L,true)if a9<=#a8 then ac(a8,a9,"trailing garbage")end;return _ end;
local lEncode, lDecode, lDigest = a3, aw, Z;
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
--! platoboost library

--! configuration
local service = 3570
local secret  = "c838d56a-8697-4af6-9677-2db396680ef7"
local useNonce = false

--! callbacks
local onMessage = function(message) end

-- wait for game to load
repeat task.wait(1) until game:IsLoaded()

-- internal shortcuts
local fSetClipboard = setclipboard or toclipboard
local fRequest      = request or http_request or syn.request
local fToString     = tostring
local fGetHwid      = gethwid or function() return game.Players.LocalPlayer.UserId end

local cachedLink, cachedTime = "", 0

-- pick host
local host = "https://api.platoboost.com"
local res = fRequest({ Url = host.."/public/connectivity", Method = "GET" })
if not res or (res.StatusCode ~= 200 and res.StatusCode ~= 429) then
    host = "https://api.platoboost.net"
end

-- cacheLink: get monetized URL
function cacheLink()
    if cachedTime + 600 < os.time() then
        local body = {
            service    = service,
            identifier = lDigest( fToString( fGetHwid() ) )
        }
        local resp = fRequest({
            Url    = host.."/public/start",
            Method = "POST",
            Body   = lEncode(body),
            Headers = { ["Content-Type"] = "application/json" }
        })
        if resp and resp.StatusCode == 200 then
            local dec = lDecode(resp.Body)
            if dec.success then
                cachedLink = dec.data.url
                cachedTime = os.time()
                return true, cachedLink
            else onMessage(dec.message) return false, dec.message end
        elseif resp and resp.StatusCode == 429 then
            local msg = "rate limited, wait"
            onMessage(msg); return false, msg
        end
        onMessage("Failed to cache link"); return false, "error"
    end
    return true, cachedLink
end

local copyLink = function()
    local success, link = cacheLink();
    
    if success then
        fSetClipboard(link);
    end
end

-- redeemKey: attempt to redeem new key
function redeemKey(key)
    local body = {
        identifier = lDigest( fToString( fGetHwid() ) ),
        key        = key
    }
    local resp = fRequest({
        Url    = host.."/public/redeem/"..fToString(service),
        Method = "POST",
        Body   = lEncode(body),
        Headers = { ["Content-Type"] = "application/json" }
    })
    if resp and resp.StatusCode == 200 then
        local dec = lDecode(resp.Body)
        if dec.success and dec.data.valid then return true end
        onMessage(dec.message or "invalid key"); return false
    elseif resp and resp.StatusCode == 429 then onMessage("rate limited"); return false end
    onMessage("server error"); return false
end

-- verifyKey: check existing or redeem
function verifyKey(key)
    -- ensure no double requests
    local endpoint = host.."/public/whitelist/"..fToString(service)
                  .."?identifier="..lDigest( fToString( fGetHwid() ) )
                  .."&key="..key
    local resp = fRequest({ Url = endpoint, Method = "GET" })
    if resp and resp.StatusCode == 200 then
        local dec = lDecode(resp.Body)
        if dec.success and dec.data.valid then return true end
        -- if invalid and prefix, try redeem
        if key:sub(1,4)=="KEY_" then return redeemKey(key) end
        onMessage("key invalid"); return false
    elseif resp and resp.StatusCode == 429 then onMessage("rate limited"); return false end
    onMessage("server error"); return false
end

-- getFlag: fetch dashboard flag
function getFlag(name)
    local endpoint = host.."/public/flag/"..fToString(service)
                  .."?name="..name
                  .."&identifier="..lDigest( fToString( fGetHwid() ) )
    local resp = fRequest({ Url = endpoint, Method = "GET" })
    if resp and resp.StatusCode==200 then
        local dec = lDecode(resp.Body)
        if dec.success then return dec.data.value end
    end
    return nil
end

--!optimize 2
local getFlag = function(name)
    local nonce = generateNonce();
    local endpoint = host .. "/public/flag/" .. fToString(service) .. "?name=" .. name;

    if useNonce then
        endpoint = endpoint .. "&nonce=" .. nonce;
    end

    local response = fRequest({
        Url = endpoint,
        Method = "GET",
    });

    if response.StatusCode == 200 then
        local decoded = lDecode(response.Body);

        if decoded.success == true then
            if useNonce then
                if decoded.data.hash == lDigest(fToString(decoded.data.value) .. "-" .. nonce .. "-" .. secret) then
                    return decoded.data.value;
                else
                    onMessage("failed to verify integrity.");
                    return nil;
                end
            else
                return decoded.data.value;
            end
        else
            onMessage(decoded.message);
            return nil;
        end
    else
        return nil;
    end
end

print("Script Loading...")
-------------------------------------------------------------------------------
-- Key System
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Platoboost + Fluent + SaveManager (persist√™ncia de Key e carregamento autom√°tico)
-------------------------------------------------------------------------------

-- Carrega libs
local Fluent           = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager      = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Configura gerenciadores
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({})
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

-- Cria janela e aba Main
local Window = Fluent:CreateWindow({
    Title = "Dead Rails Auto Bonds | ",
    SubTitle = " By: Blanksevenx",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl
})
local Tabs = { Main = Window:AddTab({ Title = "Main" }) }
Window:SelectTab(1)

-------------------------------------------------------------------------------
-- UI: Campo de input e bot√µes
-------------------------------------------------------------------------------

local inputKey = "" -- vari√°vel para armazenar a key digitada

local inputField = Tabs.Main:AddInput("KeyInput", {
    Title       = "Enter Key:",
    Default     = "",
    Placeholder = "FREE_...",
    Finished    = false,
    Callback    = function(value) -- receber o valor digitado
        inputKey = value -- atualizar a vari√°vel com o valor do input
    end
})

Tabs.Main:AddButton({
    Title       = "Check Key.",
    Description = "Check Your Key.",
    Callback    = function()
        local key = inputKey or ""
        local ok, valid = pcall(verifyKey, key)
        if ok and valid then
            Fluent:Notify({ Title = "Success!", Content = "Key Verified Successfully.", Duration = 5 })
            SaveManager:Save("SavedKey")
            writefile(SaveManager.Folder .. "/settings/autoload.txt", "SavedKey")
            Window:Destroy()

            if game.PlaceId == 116495829188952 then
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer

local gui = Instance.new("ScreenGui")
gui.Name = "SevenIsHere"
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.DisplayOrder = 999999999999
gui.Parent = player:WaitForChild("PlayerGui")

-- Frame principal
local frame = Instance.new("Frame", gui)
frame.AnchorPoint = Vector2.new(0, 0)
frame.Size = UDim2.new(1, 0, 1, 0)
frame.Position = UDim2.new(0, 0, 0, 0)
frame.Transparency = 1
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)

-- Cr√©ditos
local creditText = Instance.new("TextLabel", frame)
creditText.Size = UDim2.new(1, 0, 0.3, 0)
creditText.Position = UDim2.new(0, 0, 0.65, 0)
creditText.BackgroundTransparency = 1
creditText.Text = "Made By: S7venIsMyName#8950\nTikTok: @blanksevenx\n üáßüá∑"
creditText.TextColor3 = Color3.fromRGB(200, 200, 200)
creditText.Font = Enum.Font.GothamBlack
creditText.TextScaled = true
creditText.TextWrapped = true

-- Atualiza√ß√µes
local updateText = Instance.new("TextLabel", frame)
updateText.Size = UDim2.new(1, 0, 0.2, 0)
updateText.Position = UDim2.new(-0.20, 0, 0.10, 0)
updateText.BackgroundTransparency = 1
updateText.Text = "[Update Logs]\n[+] Lobby Executer System\n[+] Auto Create Party"
updateText.TextColor3 = Color3.fromRGB(255, 0, 149)
updateText.Font = Enum.Font.GothamBlack
updateText.TextScaled = true
updateText.TextWrapped = true

local NextUpdate = Instance.new("TextLabel", frame)
NextUpdate.Size = UDim2.new(0.6, 0, 0.14, 0)
NextUpdate.Position = UDim2.new(0.45, 0, 0.10, 0)
NextUpdate.BackgroundTransparency = 1
NextUpdate.Text = "[Next Update:]\n[/] More Fast."
NextUpdate.TextColor3 = Color3.fromRGB(255, 0, 149)
NextUpdate.Font = Enum.Font.GothamBlack
NextUpdate.TextScaled = true
NextUpdate.TextWrapped = true
            
local teleportZones = game:GetService("Workspace").TeleportZones
local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local runService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")

local guiPath = player:WaitForChild("PlayerGui"):WaitForChild("CreateParty")

local speed = 15
local reachedThreshold = 2
local isMoving = false
local activeConnection = nil
local currentTarget = nil
local monitoring = true

local zones = {
	{
		count = teleportZones.TeleportZone.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone.ZoneContainer
	},
	{
		count = teleportZones.TeleportZone1.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone1.ZoneContainer
	},
	{
		count = teleportZones.TeleportZone2.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone2.ZoneContainer
	},
	{
		count = teleportZones.TeleportZone3.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone3.ZoneContainer
	}
}

-- Parar tudo
local function stopAll()
	if activeConnection then
		activeConnection:Disconnect()
		activeConnection = nil
	end
	isMoving = false
	currentTarget = nil
	monitoring = false

	-- Criar party
	local args = {
		[1] = {
			["gameMode"] = "Normal",
			["maxPlayers"] = 1
		}
	}
	replicatedStorage.Shared.RemotePromise.Remotes.C_CreateParty:FireServer(unpack(args))
end

-- Movimento com verifica√ß√£o
local function moveToZone(zone)
	currentTarget = zone
	isMoving = true

	activeConnection = runService.Heartbeat:Connect(function(deltaTime)
		if not monitoring then return end
		if guiPath.Enabled then
			stopAll()
			return
		end

		local guiText = currentTarget.count.Text
		local targetPosition = currentTarget.container.Position
		local distance = (targetPosition - hrp.Position).Magnitude

		if guiText ~= "0/4" then
			if activeConnection then
				activeConnection:Disconnect()
			end
			isMoving = false
			currentTarget = nil
			return
		end

		if distance <= reachedThreshold then
			-- Espera ativa√ß√£o da GUI
			task.spawn(function()
				repeat task.wait(0.1) until guiPath.Enabled
				stopAll()
			end)
		else
			local direction = (targetPosition - hrp.Position).Unit
			local moveStep = math.min(distance, speed * deltaTime)

			-- Aqui √© onde corrigimos a altura
			hrp.CFrame = CFrame.new(hrp.Position + (direction * moveStep) + Vector3.new(0, 0.6, 0))
		end
	end)
end

-- Monitoramento principal
task.spawn(function()
	while monitoring do
		if guiPath.Enabled then
			stopAll()
			break
		end

		if not isMoving then
			local found = false
			for _, zone in ipairs(zones) do
				if zone.count.Text == "0/4" then
					moveToZone(zone)
					found = true
					break
				end
			end

			if not found then
				-- Espera at√© alguma zona ficar 0/4 ou a GUI ativar
				repeat
					if guiPath.Enabled then
						stopAll()
						return
					end
					task.wait(0.3)
				until not isMoving and table.find({
					zones[1].count.Text,
					zones[2].count.Text,
					zones[3].count.Text,
					zones[4].count.Text
				}, "0/4")
			end
		end
		task.wait(0.2)
	end
end)

            elseif game.PlaceId == 70876832253163 then
                -- Executa o outro script
                L7ADER()
            end
        else
            Fluent:Notify({ Title = "Error!", Content = "Invalid Key.", Duration = 5 })
        end
    end
})


Tabs.Main:AddButton({
    Title       = "Get Key Link",
    Description = "Get Your Key.",
    Callback    = function()
        copyLink()
        Fluent:Notify({ Title = "Link", Content = "Copied To Clipboard.Ô∏è", Duration = 5 })
    end
})


Fluent:Notify({ Title = "Last Updated | 02/05/2025", Content = "Lobby System | Auto Party System.", Duration = 10 })
-------------------------------------------------------------------------------
-- Carrega e verifica key salva
-------------------------------------------------------------------------------
SaveManager:LoadAutoloadConfig()  -- carrega JSON SavedKey e preenche inputField

-- Ap√≥s carregar, checa valor
local saved = inputField.Value or ""
if saved ~= "" then
    local ok, valid = pcall(verifyKey, saved)
    if ok and valid then
        Fluent:Notify({ Title = "Success !", Content = "Loading Saved Key...", Duration = 5 })
            Window:Destroy()
            if game.PlaceId == 116495829188952 then
            local Players = game:GetService("Players")
            local player = Players.LocalPlayer

local gui = Instance.new("ScreenGui")
gui.Name = "SevenIsHere"
gui.IgnoreGuiInset = true
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.DisplayOrder = 999999999999
gui.Parent = player:WaitForChild("PlayerGui")

-- Frame principal
local frame = Instance.new("Frame", gui)
frame.AnchorPoint = Vector2.new(0, 0)
frame.Size = UDim2.new(1, 0, 1, 0)
frame.Position = UDim2.new(0, 0, 0, 0)
frame.Transparency = 1
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)

-- Cr√©ditos
local creditText = Instance.new("TextLabel", frame)
creditText.Size = UDim2.new(1, 0, 0.3, 0)
creditText.Position = UDim2.new(0, 0, 0.65, 0)
creditText.BackgroundTransparency = 1
creditText.Text = "Made By: S7venIsMyName#8950\nTikTok: @blanksevenx\n üáßüá∑"
creditText.TextColor3 = Color3.fromRGB(200, 200, 200)
creditText.Font = Enum.Font.GothamBlack
creditText.TextScaled = true
creditText.TextWrapped = true

-- Atualiza√ß√µes
local updateText = Instance.new("TextLabel", frame)
updateText.Size = UDim2.new(1, 0, 0.2, 0)
updateText.Position = UDim2.new(-0.20, 0, 0.10, 0)
updateText.BackgroundTransparency = 1
updateText.Text = "[Update Logs]\n[+] Lobby Executer System\n[+] Auto Create Party"
updateText.TextColor3 = Color3.fromRGB(255, 0, 149)
updateText.Font = Enum.Font.GothamBlack
updateText.TextScaled = true
updateText.TextWrapped = true

local NextUpdate = Instance.new("TextLabel", frame)
NextUpdate.Size = UDim2.new(0.6, 0, 0.14, 0)
NextUpdate.Position = UDim2.new(0.45, 0, 0.10, 0)
NextUpdate.BackgroundTransparency = 1
NextUpdate.Text = "[Next Update:]\n[/] More Fast."
NextUpdate.TextColor3 = Color3.fromRGB(255, 0, 149)
NextUpdate.Font = Enum.Font.GothamBlack
NextUpdate.TextScaled = true
NextUpdate.TextWrapped = true
            
local teleportZones = game:GetService("Workspace").TeleportZones
local players = game:GetService("Players")
local player = players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local runService = game:GetService("RunService")
local replicatedStorage = game:GetService("ReplicatedStorage")

local guiPath = player:WaitForChild("PlayerGui"):WaitForChild("CreateParty")

local speed = 15
local reachedThreshold = 2
local isMoving = false
local activeConnection = nil
local currentTarget = nil
local monitoring = true

local zones = {
	{
		count = teleportZones.TeleportZone.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone.ZoneContainer
	},
	{
		count = teleportZones.TeleportZone1.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone1.ZoneContainer
	},
	{
		count = teleportZones.TeleportZone2.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone2.ZoneContainer
	},
	{
		count = teleportZones.TeleportZone3.BillboardGui.PlayerCount,
		container = teleportZones.TeleportZone3.ZoneContainer
	}
}

-- Parar tudo
local function stopAll()
	if activeConnection then
		activeConnection:Disconnect()
		activeConnection = nil
	end
	isMoving = false
	currentTarget = nil
	monitoring = false

	-- Criar party
	local args = {
		[1] = {
			["gameMode"] = "Normal",
			["maxPlayers"] = 1
		}
	}
	replicatedStorage.Shared.RemotePromise.Remotes.C_CreateParty:FireServer(unpack(args))
end

-- Movimento com verifica√ß√£o
local function moveToZone(zone)
	currentTarget = zone
	isMoving = true

	activeConnection = runService.Heartbeat:Connect(function(deltaTime)
		if not monitoring then return end
		if guiPath.Enabled then
			stopAll()
			return
		end

		local guiText = currentTarget.count.Text
		local targetPosition = currentTarget.container.Position
		local distance = (targetPosition - hrp.Position).Magnitude

		if guiText ~= "0/4" then
			if activeConnection then
				activeConnection:Disconnect()
			end
			isMoving = false
			currentTarget = nil
			return
		end

		if distance <= reachedThreshold then
			-- Espera ativa√ß√£o da GUI
			task.spawn(function()
				repeat task.wait(0.1) until guiPath.Enabled
				stopAll()
			end)
		else
			local direction = (targetPosition - hrp.Position).Unit
			local moveStep = math.min(distance, speed * deltaTime)

			-- Aqui √© onde corrigimos a altura
			hrp.CFrame = CFrame.new(hrp.Position + (direction * moveStep) + Vector3.new(0, 0.6, 0))
		end
	end)
end

-- Monitoramento principal
task.spawn(function()
	while monitoring do
		if guiPath.Enabled then
			stopAll()
			break
		end

		if not isMoving then
			local found = false
			for _, zone in ipairs(zones) do
				if zone.count.Text == "0/4" then
					moveToZone(zone)
					found = true
					break
				end
			end

			if not found then
				-- Espera at√© alguma zona ficar 0/4 ou a GUI ativar
				repeat
					if guiPath.Enabled then
						stopAll()
						return
					end
					task.wait(0.3)
				until not isMoving and table.find({
					zones[1].count.Text,
					zones[2].count.Text,
					zones[3].count.Text,
					zones[4].count.Text
				}, "0/4")
			end
		end
		task.wait(0.2)
	end
end)
            elseif game.PlaceId == 70876832253163 then
                -- Executa o outro script
                L7ADER()
            end
    else
        Fluent:Notify({ Title = "Error !", Content = "Expired Key.", Duration = 5 })
    end
end